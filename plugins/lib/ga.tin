#nop vim: set filetype=tt:;

/*
本文件属于 PaoTin++ 的一部分
===========
PaoTin++ © 2020~2023 的所有版权均由担子炮(dzp <danzipao@gmail.com>) 享有并保留一切法律权利
你可以在遵照 GPLv3 协议的基础之上使用、修改及重新分发本程序。
===========
*/

#var lib_ga[META] {
    {NAME}      {GA}
    {DESC}      {GA 处理。IAC GA 是服务器信息输出结尾符号}
    {AUTHOR}    {担子炮}
    {NOTE}      {本文件属于 PaoTin++ 的一部分}
};

#config {IAC GA} {ON};

#func {lib_ga.Init} {
    #class data/lib/ga open;
    #list gXttPipeLine create {};
    #class data/lib/ga close;

    ttevent.Handle {SENT OUTPUT}        {lib/ga} {lib/ga} {ga.send-output};
    ttevent.Handle {RECEIVED PROMPT}    {lib/ga} {lib/ga} {ga.received-prompt};

    #return true;
};

load-lib telnet;

event.Define {GA} {有参} {$MODULE} {接收到 IAC GA 时发射本事件，参数为造成本次输出的命令};

#alias {ga.send-output} {
    #local cmd {$gTTEventArgZero};
    #replace cmd {{$TELNET[CR]?}$TELNET[LF]} {};
    #list gXttPipeLine add {$cmd};
};

/*
   这里主要目的是处理非标 GA 并努力维持命令和 GA 的对应关系。
   如果命令和 GA 不对应，就要在这里调整。
   主要是记录那些一个命令可能会导致多个 GA 的情形，
   以及 GA 前的提示文本非标的情形。
*/
#alias {ga.received-prompt} {
    #local line     {$gTTEventArgv[1]};

    #if { "$line" == "== 未完继续 %*== (%*继续下一页%*)%*" } {
        #line gag; #cr; #return;
    };

    #if { "$line" != "> %*" } {
        #local cmd {$gXttPipeLine[1]};
        #list gXttPipeLine delete {1};
        #if { &gXttPipeLine[] == 0 } {
            xtt.DisableAllCommands false;
            #line oneshot #alias {^%*{|ID=lib/ga}$} {
                #list gXttPipeLine add {{%%0}};
                #send %%0;
                xtt.UndoDisableAllCommands;
            } {1.000};
        };
    };
};

#action {^> {$TELNET[GA]|$TELNET[EOR]}$} {
    #local cmd {};

    #if { &gXttPipeLine[] > 0 } {
        #local cmd {$gXttPipeLine[1]};
        #list gXttPipeLine delete {1};
    };
    #else {
        errLog 遭遇意料之外的 GA，请联系开发者。;
    };

    event.Emit GA {} {$cmd};

    #line gag;

} {1.000};

#alias {ga.Off} {
    #send {$TELNET[IAC]$TELNET[WILL]$TELNET[LINEMODE]\};
    #send {$TELNET[IAC]$TELNET[DO]$TELNET[SGA]\};
};

#alias {ga.On} {
    #send {$TELNET[IAC]$TELNET[WILL]$TELNET[LINEMODE]\};
    #send {$TELNET[IAC]$TELNET[DONT]$TELNET[SGA]\};
};

#alias {ga.Sync} {
    sync.Wait {#0};
};

#alias {ga.Confirm} {
    #local cmd {%1};

    #if { &gXttPipeLine[] > 0 && {$gXttPipeLine[1]} !== {$cmd} } {
        dbgLog GA => GA 状态已失步，现在开始同步。;
    };
    #while { &gXttPipeLine[] > 0 && {$gXttPipeLine[1]} !== {$cmd} } {
        dbgLog GA => drop $gXttPipeLine[1];
        #list gXttPipeLine delete {1};
    };
};

///=== {
// ## ga.Wait <回调代码> <钩子名称>
//    等待下一个 GA 的到来，并在那时执行回调代码。
// };
#alias {ga.Wait} {
    #local code     {%21};
    #local hook     {%2};

    #if { "$code" == "" || "$hook" == "" } {
        xtt.Usage ga.Wait;
        #return;
    };

    #line sub {escapes} event.HandleOnce GA {ga/$hook} {GA} {%21;#0};
};

///=== {
// ## ga.ClassWait <回调代码> [<钩子名称>]
//    类似于 ga.Wait，但是会在当前 #class 消亡时自动注销。
//    因为可以自动注销，因此钩子名称可以省略。
// };
#alias {ga.ClassWait} {
    #local code     {%21};
    #local hook     {@default{{%2};@uuid{}}};

    #if { "$code" == "" } {
        xtt.Usage ga.ClassWait;
        #return;
    };

    #line sub {escapes} event.ClassHandleOnce GA {ga/$hook} {GA} {%21;#0};
};

///=== {
// ## ga.Ignore <钩子名称>
//    忽略之前用 ga.Wait 或者 ga.ClassWait 注册的钩子。
// };
#alias {ga.Ignore} {
    #local hook {%1};

    #if { "$hook" == "" } {
        xtt.Usage ga.Ignore;
        #return;
    };

    event.UnHandle GA {ga/$hook} {GA};
};

#func {ga.ThisCmd} {
    #return {$gXttPipeLine[1]};
};

#func {ga.IsUnderway} {
    #if { &gXttPipeLine[] > 1 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

#func {ga.AllDone} {
    #if { &gXttPipeLine[] == 0 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};
